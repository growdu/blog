# vpp vector指北

版权声明：本文为CSDN博主「成王君」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_45429253/article/details/97020110

## vectors 的本质

### 外在表现

很简单，实际上就是一个动态的可变大小数组。这个数组：

- 每个元素的大小可以变化，数组大小可以变化。从而使得其可以作为任何数据结构的存储结构，事实上，VPP就是这样做的，所有数据结构的存储结构就是vectors。
- 用户自定义头结构，表示vectors表示的存储结构对应的全部或部分逻辑结构的信息。
- 利用头部位图表示数组某个元素是否已经被使用
- 用户可以用C数组的访问方式访问vectors，效率极高
- 提供了一系列对vectors的操作宏，函数。
- 对vector中的数据结构，经过指针变换后，仍然保持原数据结构的访问方式。

### 为什么定义vectors结构

这实际上是网络操作系统多年实践中得来的经验。作为转发协议栈：

1. 需要极致高效，
2. 从1， 各模块需要共享数据结构
3. 新的特性，协议及相关的安全需求不断出现导致其更新永不停，
4. 可移植，可维护，可扩展，可测试，可调试
5. 热插拔，主备冗余转发表数据同步及恢复

> 这些需求直接导致的就是转发协议栈程序极易出现bug，尤其是内存相关的bug。因此，普遍的，网络操作系统通常自己实现一个内部的内存管理系统，期待更细致的跟踪每个模块甚至每个数据结构的内存使用，但这种系统往往仍然是一个大一统方案，仅仅增加了一些公用的使用统计信息，对每个数据结构的分析仍然要依靠各模块做额外的开发工作。
> vectors则是从基础的存储结构的角度出发，统一了所有数据结构的存储结构，从而强行使得每个数据结构规范自己的内存管理。同时又尽量的贴近C语言内存使用习惯，编码和运行都能高效化。
> 使用vectors后，可以仅在vectors层面即可生成程序运行时数据快照（很遗憾，这部分VPP没有实现，个人认为cisco开源时故意拿去了这一部分）。可以利用外部程序对数据快照进行自动化分析。使得问题分析和运行时解耦，减轻在各程序模块针对快照数据分析的开发及其带来的一系列麻烦。同时可以使用更合适的工具进行分析，提高运行时及分析效率。
> 同时，vectors这种数组设计，使得数据同步及恢复可以批量copy，不但高效而且可以简化和更好的模块化相关程序（VPP中没有实现）。

## vector的使用

### 作为常规的内存操作来使用

>vec_resize，vec_alloc，vec_new，vec_add，vec_add1，vec_add2等都可用于常规的内存申请（类似malloc），统一用vec_free做内存释放（类似free）。
>vec_dup，vec_copy，vec_clone完成内存复制（类似memcpy）
>vec_cmp完成内存比较（类似memcmp）
>vec_zero完成内存清零（类似memset）
>vec_set完成内存设置为某个值（memset）

### 作为常用数据结构使用

- 数组

  >vectors本身就是一个极佳的动态数组实现。
  > vec_insert ,vec_insert_elts数组内插入元素；
  > vec_del，vec_delete数组内删除元素；
  > vec_append，vec_prepend连接两个数组；

- 其他数据结构

  对于其他结构，必须熟悉利用数组作为存储结构的实现方式，而且，通常会附加很多算法技巧。

## 总结

vectors本质上提供了一种针对每一种数据结构的高效的内存管理机制。利用vectors作为基础存储结构，可以有效降低程序中内存问题bug。并为对程序运行时数据分析，数据同步，恢复等奠定了良好的基础。

# reference

1. https://blog.csdn.net/weixin_45429253/article/details/97020110