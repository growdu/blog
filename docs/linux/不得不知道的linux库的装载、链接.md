# 不得不知道的linux库的装载、链接

在计算机世界里，一直有一个和现实世界一样非常重要的概念，那就是地址。就像是某个国家某个地点，才能找到某个人一样。
同样地，在计算机世界里，同样需要地址，在这样的地址能够找到某个文件或者某个符号。
换句话说，在计算机世界里，你要找到某个文件、某个进程、某个函数做某件事情，都需要知道他的地址。
在最上层，地址分为如下几类：（这个时候还没有操作系统）

- 物理内存地址
- 磁盘地址
- cpu地址
- 缓存地址
- 显卡地址
- 等等

这个时候，这些地址都是实际的物理硬件，通过物理连线形成地址。
从上电的那一瞬间开始，主板上的相关芯片根据物理线路首先编排好了地址，当操作系统运行起来后，这些地址都会被抽象到操作系统里，由操作系统进行映射。

同时，操作系统运行起来后，那些物理资源的地址就被映射到了用户空间，比如

- 虚拟内存地址—— 这个是编程人员可以看到的
- 用户目录地址—— 这个是普通用户就可以看到的
- ip地址—— 这个是运营商分配的

而对于编程人员和普通用户来说，最重要的就是目录地址或者说文件地址，这个地址贯穿所有应用程序的始终。

一个程序要运行起来，分成两种：

- 一种是程序没有任何依赖，自个就能运行起来
- 另外一种是程序依赖于其他组件，这个时候就必须要告诉你的程序到哪些地方去寻找相关的依赖了

好了，到这里就说清楚了一个问题，地址很重要，如何去寻找地址以及找不找得到地址决定了你的程序能不能执行。

## 环境变量

环境变量就是告诉操作系统去哪里寻找二进制文件，主要是可执行文件。
如果你的可执行文件在环境变量的目录下可以找到，那么使用可执行文件名即可运行。
如果你的可执行文件在环境变量的目录下找不到，那么就必须带完整路径可以运行。

## 依赖库路径

当然运行会不会报错，还要看依赖库有没有缺失。而依赖库的路径又分成两类：

- 编译时路径—— 就是你在编译二进制时如何链接依赖库
- 运行时路径—— 就是在运行二进制时去哪里查找依赖库

对于C语言程序来说，编译时将安装如下顺序去查找库来进行链接：

- 编译参数-L指定的路径
- /usr/lib64
- /usr/lib/gcc/gcc平台/gcc版本
- /usr/local/lib64
- /lib64
- /lib
- /usr/lib

在编译程序时，若出现找不到库的报错，可以在gcc编译时加上如下参数：

```shell
gcc -v -x c -E
```
同时查看ld的查找路径：

```shell
gcc -v -x c -E
```


对于c语言的库来说，运行时按照如下顺序去查找库：

- LD_LIBRARY_PATH设置的值
- /etc/ld.so.conf文件中设置的目录
- /etc/ld.so.conf.d目录下的文件设置的目录
- 当前目录

<font color="red">需要特别注意的是：LD_LIBRARY_PATH影响的是运行时，无法影响编译时。</font>