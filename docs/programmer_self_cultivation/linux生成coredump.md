# linux生成coredump

## 修改ulimit

```shell
ulimit -c 0              #不产生core文件
ulimit -c 100            #设置core文件最大为100k
ulimit -c unlimited      #不限制core文件大小  
```

```shell
(base) ┌──(dys㉿kali)-[~]
└─$ ulimit -c
0
```

可以看到本机未开启core dump。执行如下命令开启，并且不限制core文件大小。

```shell
(base) ┌──(dys㉿kali)-[~]
└─$ ulimit -c unlimited

(base) ┌──(dys㉿kali)-[~]
└─$ ulimit -c
unlimited
```
上述方法只是临时生效，要想永久生效需执行如下命令：

```shell
(base) ┌──(dys㉿kali)-[~]
└─$ echo "ulimit -c unlimited" >> ~/.zshrc
# 如果是bash就换成~/.bashrc
```

## 修改core文件位置

那么生成的core文件在哪里呢？

默认情况下，core dump生成的文件名为core，而且就在程序当前目录下。新的core会覆盖已存在的core, 通过修改/proc/sys/kernel/core_uses_pid文件，可以控制core文件保存位置和文件格式。

```shell
(base) ┌──(dys㉿kali)-[~]
└─$ cat /proc/sys/kernel/core_uses_pid
0

(base) ┌──(dys㉿kali)-[~]
└─$ cat /proc/sys/kernel/core_pattern # 生成core文件的路径和格式，默认core且在当前路径下
core
```

将core文件生成修改为/opt/corefile下。

```shell
sudo vim /etc/sysctl.conf

kernel.core_pattern=/opt/corefile/core_%t_%e_%p
kernel.core_uses_pid=0
```

```shell
%c 转储文件的大小上限
%e 所dump的文件名
%g 所dump的进程的实际组ID
%h 主机名
%p 所dump的进程PID
%s 导致本次coredump的信号
%t 转储时刻(由1970年1月1日起计的秒数)
%u 所dump进程的实际用户ID
```



执行如下命令生效：

```shell
(base) ┌──(dys㉿kali)-[~]
└─$ sudo sysctl -p
kernel.core_pattern = /opt/corefile/core_%t_%e_%p
kernel.core_uses_pid = 0
```
测试是否生效：

```shell
(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ cat main.c
#include <stdio.h>
struct hello {
    char a;
    int b;
};
int main()
{
    struct hello *p = NULL;
    printf("Hello world, p is %c\n", p->a);
    return 0;
}


(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ gcc -g -O0 main.c -o hello-world

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ls
hello-world  main.c

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ./hello-world
zsh: segmentation fault  ./hello-world
```

可以看到未生成coredump文件。在下列条件下不产生core 文件：

- 进程是设置- 用户-ID ，而且当前用户并非程序文件的所有者；
- 进程是设置- 组-ID ，而且当前用户并非该程序文件的组所有者；
- 用户没有写当前工作目录的许可权；
- 文件太大。core 文件的许可权( 假定该文件在此之前并不存在) 通常是用户读/ 写，组读和其他读。

```shell
(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ulimit -c
unlimited

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ls -al /opt/corefile
总用量 8
drwxr-xr-x 2 root root 4096  6月 22 15:29 .
drwxr-xr-x 4 root root 4096  6月 22 15:29 ..

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ sudo chown dys:dys /opt/corefile -R

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ./hello-world
zsh: segmentation fault (core dumped)  ./hello-world

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ls -al /opt/corefile
总用量 136
drwxr-xr-x 2 dys  dys    4096  6月 22 15:35 .
drwxr-xr-x 4 root root   4096  6月 22 15:29 ..
-rw------- 1 dys  dys  303104  6月 22 15:35 core_1687419341_hello-world_15645
```

修改文件权限后，coredump文件正常生成。

## 查看coredump文件

使用gdb 二进制名称 core文件路径来查看coredump文件。

```shell
(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ./hello-world
zsh: segmentation fault (core dumped)  ./hello-world

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ ls -al /opt/corefile
总用量 136
drwxr-xr-x 2 dys  dys    4096  6月 22 15:44 .
drwxr-xr-x 4 root root   4096  6月 22 15:29 ..
-rw------- 1 dys  dys  303104  6月 22 15:44 core_1687419846_hello-world_18988

(base) ┌──(dys㉿kali)-[/fast1/code/cwork/psc]
└─$ gdb hello-world /opt/corefile/core_1687419846_hello-world_18988 -q
Reading symbols from hello-world...
[New LWP 18988]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./hello-world'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x000055b51d67c14d in main () at main.c:9
9           printf("Hello world, p is %c\n", p->a);
(gdb)
```

