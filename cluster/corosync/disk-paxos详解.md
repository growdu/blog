# disk-paxos详解

 Disk Paxos使用处理器和磁盘网络实现可靠的分布式系统。 与原始 Paxos 算法一样，Disk Paxos 可以保证在任意非拜占庭故障的情况下保持一致性。 只要大多数磁盘可用，即使仅剩下一个节点也能保证进程可用，且保持一致性。

 ## 简介

 容错需要冗余组件。 在系统分区的情况下保持一致性使得双组件系统在任何一个组件发生故障时都无法正常工作。 用于实现分布式系统的容错算法有无数种，我们所知道的算法都将组件与处理器等同起来。 但还有其他类型的组件可以替代。 特别是，现代网络现在将磁盘驱动器作为独立组件。 由于磁盘比计算机便宜，因此使用它们作为实现容错的复制组件很有吸引力。 磁盘与处理器的不同之处在于磁盘不可编程，因此我们不能仅用磁盘替换现有算法中的处理器。

我们在这里提出一种称为 Disk Paxos 的算法，它通过处理器和磁盘网络实现任意容错系统。 它在发生任意数量的非拜占庭故障时保持一致性。也就是说，处理器可以暂停任意长的时间，可能完全失败，并且可以在失败后重新启动，只记住它已经失败了； 某些或所有处理器可能无法访问磁盘，但它可能不会损坏。 如果系统稳定并且至少有一个无故障的处理器可以读取和写入大多数磁盘，则 Disk Paxos 可以保证正常服务。 稳定性意味着每个处理器要么没有故障，要么完全失效，并且非故障处理器可以访问非故障磁盘。 例如，它允许两个处理器和三个磁盘的系统在任何一个处理器和任何一个磁盘发生故障后继续前进。

Disk Paxos 是经典 Paxos 算法的变体[3,12,14]，是一种简单、高效的算法，已在实际分布式系统中使用[15,18]。 Classic Paxos可以看作是Disk Paxos的一种实现，其中每个处理器有一个磁盘，并且磁盘只能由其处理器直接访问。在下一节中，我们回顾一下如何将实现任意分布式系统的问题简化为共识问题。 第3节非正式地描述了Disk Synod，Disk Paxos使用的共识算法。它包括一个不完全正确性证明的草图，并解释了Disk Synod和经典Paxos的Synod协议之间的关系。 第 4 节简要讨论了一些实现细节并包含常规的结论性意见。 附录给出了共识问题和 Disk Synod 算法的正式规范，并勾勒出严格的正确性证明。

缺少任何证明的附录 1 的删节版本，出现的较早 [5]。

## 状态机

状态机 [7, 16] 是实现任意分布式系统的通用方法。 该系统被设计为执行一系列命令的确定性状态机，并且共识算法确保对于每个 n，所有处理器都同意第 n 个命令。 这减少了构建任意系统来解决共识问题的问题。 在共识问题中，每个处理器 p 以一个输入值 input[p] 开始，并且它可能输出一个值。 解决方案应该是：

- **非零解** 对于某个处理器 p，任何值输出都应该是某个时间 input[p] 的值。 （如果 p 失败并重新启动，则 input[p] 的值可能会更改。）
- **一致性** 所有输出的值都是相同的。当系统稳定并且无故障的处理器（非阻塞的）可以与大多数磁盘通信，那么处理器最终将输出一个值。

众所周知，使用异步消息传递的一致、非阻塞共识总是需要至少两次消息延迟 [6]。使用较少消息延迟的非阻塞算法不能保证一致性。 例如，Isis [2] 的组通信算法允许属于当前组的两个处理器对于消息是否在它们所属的前一个组中广播存在分歧。 该算法本身无法保证一致性，因为对消息是否已广播的分歧可能会导致对输出值的分歧。

经典的Paxos算法[3,12,14]使用三阶段共识协议，称为Synod算法，其中前两个阶段中的每个阶段都需要两次消息延迟，第三阶段只是广播输出值。然而，直到第二阶段才选择要输出的值。 当选举出新的领导者时，它只为所有后续系统命令执行的整个共识算法序列执行第一阶段一次。只有最后两个阶段为每个单独的命令单独执行。

在 Disk Synod 算法（DiskPaxos 使用的共识算法）中，每个处理器在每个磁盘上都有一个分配的块。 该算法有两个阶段。 在每个阶段，处理器写入自己的块并读取大多数磁盘上其他处理器的块。 每个命令仅需要重新执行最后一个阶段。 因此，在正常的稳态情况下，领导者通过对其每个块执行一次写入，并对每个其他处理器的块执行一次读取来选择状态机命令。

Disk Paxos 与经典 Paxos 一样，不做时序假设； 进程可能是完全异步的。 Fischer、Lynch 和 Paterson [4] 的经典结果意味着纯粹的异步非阻塞共识算法是不可能的。 因此，必须引入时钟和实时假设。 典型的行业方法是使用基于超时的临时算法来选举领导者，然后让领导者选择输出[17, 19]。 设计一种在系统稳定时有效的领导者选举算法很容易，这意味着它在大多数时间都有效。 很难做出一个即使在系统不稳定的情况下也能始终正常工作的系统。 经典 Paxos 和 Disk Paxos 都采用实时算法来选举领导者。 然而，领导者仅用于确保进度。即使有多个领导者，也能保持一致性。 因此，如果领导者选举算法由于网络不稳定而失败，系统可能无法取得进展，它不会变得不一致。 当系统变得稳定并选出一位领导者时，系统将再次取得进展。

## disk synod的非正式描述

我们现在非正式地描述 Disk Synod 算法并解释它的工作原理。 我们还讨论了它与经典 Paxos 的 Synod 协议的关系。请记住，在正常操作中，只有一个领导者将执行该算法。 其他处理器不执行任何操作； 他们只是等待领导者通知他们结果。 然而，即使由多个处理器执行，或者领导者在宣布结果之前失败并选择新的领导者，该算法也必须保持一致性。

### 算法描述

我们假设每个处理器 p 以一个输入值 input[p] 开始。Asin Paxos 的 Synod 算法，处理器执行一系列编号选票，选票编号不断增加。 选票号是正整数，不同的处理器使用不同的选票号。 例如，如果处理器编号为 1 到 N ，则处理器 i 可以使用选票编号 i、i + N 、 i + 2N 等。处理器 p 分两个阶段执行选票，第一个阶段尝试选择一个值，第二个阶段尝试提交该值：

- **阶段一** 确定 p 是否可以选择其输入值 input[p] 或者必须选择其他值。选择一个值v。
- **阶段二** 尝试提交v。
值 v 的选择发生在从阶段 1 到阶段 2 的过渡中。当 p 完成阶段 2 时，该值被提交并可以输出。

在任一阶段，如果处理者得知另一个处理者已开始编号更高的投票，则它会中止其投票。 在这种情况下，处理者可以选择更高的选票号码并开始新的选票。 （如果它仍然认为自己是领导者，它就会这样做。）如果处理器完成第 2 阶段而没有中止，即没有获知更高编号的选票，则值 v 被提交并且处理器可以输出它。 处理器 p 在进入阶段 2 之前不需要知道input[p]的值，因此可以针对算法的任意数量的单独实例提前执行阶段 1。

为了确保一致性，我们必须保证两个不同的值不能成功提交——无论是由不同的处理器（因为领导者选举算法尚未成功）还是由同一处理器在两次不同的选票中成功提交（因为它失败并重新启动）。 为了确保算法是非阻塞的，我们必须保证，如果只有一个处理器 p 执行它，那么 p 最终会提交一个值。

实际上，当处理器成功提交一个值时，它将在其磁盘块上写入该值已提交，并将该事实广播给其他处理器。 如果处理器得知某个值已被提交，它将中止其投票并简单地输出该值。 很明显，这种优化保留了正确性； 我们不会进一步考虑它。为了执行该算法，处理器 p 维护一条记录 dblock[p]，其中包含以下三个组成部分：

- bal 当前选票号
- mbal p进入第2阶段的最大选票数
- inp 值 尝试在选票号 bal 中提交的值

最初，bal 等于 0，inp 等于特殊值 NotAnInput，它不是可能的输入值，mbal 是其任何可能的选票号码。 我们让disk[d][p]为磁盘d上的块，处理器p在其中写入dblock[p]。 我们假设读取和写入块是原子操作。

处理器 p 如下执行投票的阶段 1 或阶段 2。 对于每个 diskd，它首先尝试将 dblock[p] 写入 disk[d][p]，然后为所有其他处理器 q 读取 disk[d][q]。 如果对于任何 d 和 q，它发现disk[d][q].mbal > dblock[p].mbal，则中止投票。 当 p 写入并读取大多数磁盘时，该阶段完成，且不读取 mbal 分量大于 dblock[p].mbal 的任何块。 当它完成阶段 1 时，p 选择 dblock[p].inp 的新值，将 dblock[p].bal 设置为 dblock[p].mbal（其当前选票编号），并开始阶段 2。当它完成阶段 2 时，phas 提交 dblock[p].inp。

为了完成对这两个阶段的描述，我们现在描述处理器 p 如何选择它在阶段 2 中尝试提交的 dblock[p].inp 的值。令blocksSeen 为由 dblock[p] 和 p 在阶段 1 中读取的所有磁盘[d][q]记录组成的集合。令 nonInitBlks 为由 inp 字段不是 NotAnInput 的记录组成的blocksSeen 的子集。 如果 nonInitBlks 为空，则 p 将 dblock[p].inp 设置为其自己的输入值 input[p]。 否则，对于 nonInitBlks 中具有 bk.bal 最大值的某些记录 bk，它将 dblock[p].inp 设置为 bk.inp。

最后，我们描述处理器 p 从故障中恢复时执行的操作。 在这种情况下，p 从大多数 disksd 中读取自己的块 disk[d][p]。 然后，它将 dblock[p] 设置为它读取的具有 bk.mbal 最大值的任何块 bk，并通过增加 dblock[p].mbal 并开始阶段 1 来开始新的投票。

图 1 非正式地总结了该算法，该图描述了处理器 p 如何执行单次投票。 处理器通过执行开始投票操作来开始投票。 如果投票中止，或者在任何其他时间，它可以开始新的投票 - 除非失败，在这种情况下，它必须执行“失败后重新启动”操作。 附录中给出了该算法的精确规范。

### 为什么算法可以安全运行

我们直观地解释了为什么Disk Synod算法满足非平凡性和一致性这两个安全属性。 非零解是平凡的，因为任何块的 val 字段总是设置为其他块的 val 字段。

- **开始投票** 
1. 将 d'block[p].mbar 设置为大于其当前值的值。
2. 将blocksSeen 设置为{d'block[p]}。
3. 开始第一阶段。
- **阶段一或者阶段二**

```shell
同时对每个磁盘 d 执行
    将 dblock[p] 写入disk[d][p].
    对于每个处理器 q（不等于p）执行
        读取disk[d][q]并将其插入到设置的blocksSeen中。
    如果 disk[d][q].mbal > dblock[p].mbal，则中止投票。
直到对大多数磁盘完成此操作。
如果是阶段一
    
```
