作者最近在实现雪花算法生成主键，看了不少文章。个人觉得雪花算法的最大的优点是有序(减少数据库的页分裂页合并)。雪花算法本身很简单，但他依赖于时间，也就是机器或容器的时间一回拨就出现问题了。网上也出现了不少关于如何解决回拨的问题。我记录一下本次实现雪花主键的过程。

先定个目标

实现雪花算法的主键

提供不同策略的时钟回拨解决方法

尽量避免完全自增，导致ID规则被发现

初识雪花算法

雪花算法生成的id的结果是一个64bit的整数，结构如下(引用网上的图片)：

![939a3aa9df97f24d1ff01b478fbaeae2.png](https://img-blog.csdnimg.cn/img_convert/939a3aa9df97f24d1ff01b478fbaeae2.png)

由此可以看出他是一个较大的正整数，在同一毫秒内，他可以生成4096个ID(12位序列号，12个1的二进制就是4095，再加个0)。所以适合并发量较大的有序ID。

由于有41位的时间戳，所以非常依赖应用程序的时间，如果时钟发生回拨，会造成前面41位的二进制重复，从而导致ID重复，这是不可取的。

时间回拨解决思路

思路一

我们的目标是想让ID有序(自增也行)。但我们的并发不可能一直很高，几乎不可能每一毫秒都是4096个插入。所以肯定有相对来说有一毫秒内用不完的序列。所以当时我就做了一个想法，我的时间戳部分能不能等这个毫秒用完了序列号再增加一毫秒。等时钟回拨的时候，我不看当前时间，我只看到了哪个时间戳。这种方式能解决时间回拨问题，但有个致命缺陷。因为你的ID永远是有规律